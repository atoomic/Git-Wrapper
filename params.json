{"name":"Git::Wrapper","tagline":"Perl wrapper for git(7) command line interface","body":"# NAME\r\n\r\nGit::Wrapper - Wrap git(7) command-line interface\r\n\r\n# VERSION\r\n\r\nversion 0.032\r\n\r\n# SYNOPSIS\r\n\r\n    my $git = Git::Wrapper->new('/var/foo');\r\n\r\n    $git->commit(...)\r\n    print $_->message for $git->log;\r\n\r\n    # specify which git binary to use\r\n    my $git = Git::Wrapper->new({\r\n      dir        => '/var/foo ,\r\n      git_binary => '/path/to/git/bin/git' ,\r\n    });\r\n\r\n# DESCRIPTION\r\n\r\nGit::Wrapper provides an API for git(7) that uses Perl data structures for\r\nargument passing, instead of CLI-style `--options` as [Git](https://metacpan.org/pod/Git) does.\r\n\r\n# METHOD INVOCATION\r\n\r\nExcept as documented, every git subcommand is available as a method on a\r\nGit::Wrapper object. Replace any hyphens in the git command with underscores\r\n(for example, 'git init-db' would become `$git-`init\\_db>).\r\n\r\n## Method Arguments\r\n\r\nMethods accept a combination of hashrefs and scalars, which is used to build\r\nthe command used to invoke git. Arguments passed in hashrefs will be\r\nautomatically parsed into option pairs, but the ordering of these in the\r\nresulting shell command is not guaranteed (with the exception of options with\r\na leading '-'; see below). Options that are passed as plain scalars will\r\nretain their order. Some examples may help clarify. This code:\r\n\r\n    $git->commit({ message => \"stuff\" , all => 1 });\r\n\r\nmay produce this shell command:\r\n\r\n    git commit --all --message=\"stuff\"\r\n\r\nThis code, however:\r\n\r\n    $git->commit(qw/ --message \"stuff\" / , { all => 1 });\r\n\r\nwill always produce this shell command:\r\n\r\n    git commit --message \"stuff\" --all\r\n\r\nIn most cases, this exact control over argument ordering is not needed and\r\nsimply passing all options as part of a hashref, and all other options as\r\nadditional list arguments, will be sufficient. In some cases, however, the\r\nordering of options to particular git sub-commands is significant, resulting\r\nin the need for this level of control.\r\n\r\n_N.b._ Options that are given with a leading '-' (with the exception of\r\nspecial options noted below) are applied as arguments to the `git` command\r\nitself; options without a leading '-' are applied as arguments to the\r\nsub-command. For example:\r\n\r\n    $git->command({ -foo => 1 , bar => 2 });\r\n\r\ninvokes the command line\r\n\r\n    git --foo=1 command --bar=2\r\n\r\n_N.b._ Because of the way arguments are parsed, should you need to pass an\r\nexplicit '0' value to an option (for example, to have the same effect as\r\n`--abrrev=0` on the command line), you should pass it with a leading space, like so:\r\n\r\n    $git->describe({ abbrev => ' 0' };\r\n\r\nTo pass content via STDIN, use the -STDIN option:\r\n\r\n    $git->hash_object({ stdin => 1, -STDIN => 'content to hash' });\r\n\r\nOutput is available as an array of lines, each chomped.\r\n\r\n    @sha1s_and_titles = $git->rev_list({ all => 1, pretty => 'oneline' });\r\n\r\n### Passing stringify-able objects as arguments\r\n\r\nObjects may be passed in the place of scalars, assuming those objects overload\r\nstringification in such a way as to produce a useful value. However, relying\r\non this stringification is discouraged and likely to be officially deprecated\r\nin a subsequent release. Instead, if you have an object that stringifies to a\r\nmeaningful value (_e.g._, a [Path::Class](https://metacpan.org/pod/Path::Class) object), you should stringify it\r\nyourself before passing it to `Git::Wrapper` methods.\r\n\r\n## Error handling\r\n\r\nIf a git command exits nonzero, a `Git::Wrapper::Exception` object will be\r\nthrown (via `die()`). These objects have three useful methods:\r\n\r\n- error\r\n\r\n    error message\r\n\r\n- output\r\n\r\n    normal output, as a single string\r\n\r\n- status\r\n\r\n    the exit status\r\n\r\nThese exception objects stringify to the error message.\r\n\r\n# METHODS\r\n\r\n## new\r\n\r\n    my $git = Git::Wrapper->new($dir);\r\n    my $git = Git::Wrapper->new({ dir => $dir , git_binary => '/path/to/git' });\r\n\r\n    # To force the git binary location\r\n    my $git = Git::Wrapper->new($dir, 'git_binary' => '/usr/local/bin/git');\r\n\r\n## git\r\n\r\n    print $git->git; # /path/to/git/binary/being/used\r\n\r\n## dir\r\n\r\n    print $git->dir; # /var/foo\r\n\r\n## version\r\n\r\n    my $version = $git->version; # 1.6.1.4.8.15.16.23.42\r\n\r\n## branch\r\n\r\n    my @branches = $git->branch;\r\n\r\nThis command intentionally disables ANSI color highlighting in the output. If\r\nyou want ANSI color highlighting, you'll need to bypass via the RUN() method\r\n(see below).\r\n\r\n## log\r\n\r\n    my @logs = $git->log;\r\n\r\nInstead of giving back an arrayref of lines, the `log` method returns a list\r\nof `Git::Wrapper::Log` objects. They have four methods:\r\n\r\n- id\r\n- author\r\n- date\r\n- message\r\n\r\n## has\\_git\\_in\\_path\r\n\r\nThis method returns a true or false value indicating if there is a 'git'\r\nbinary in the current $PATH.\r\n\r\n## supports\\_status\\_porcelain\r\n\r\n## supports\\_log\\_no\\_abbrev\\_commit\r\n\r\n## supports\\_log\\_raw\\_dates\r\n\r\n## supports\\_hash\\_object\\_filters\r\n\r\nThese methods return a true or false value (1 or 0) indicating whether the git\r\nbinary being used has support for these options. (The '--porcelain' option on\r\n'git status', the '--no-abbrev-commit' and '--date=raw' options on 'git log',\r\nand the '--no-filters' option on 'git hash-object' respectively.)\r\n\r\nThese are primarily for use in this distribution's test suite, but may also be\r\nuseful when writing code using Git::Wrapper that might be run with different\r\nversions of the underlying git binary.\r\n\r\n## status\r\n\r\nWhen running with an underlying git binary that returns false for the\r\n[\"supports\\_status\\_porcelain\"](#supports_status_porcelain) method, this method will act like any other\r\nwrapped command: it will return output as an array of chomped lines.\r\n\r\nWhen running with an underlying git binary that returns true for the\r\n[\"supports\\_status\\_porcelain\"](#supports_status_porcelain) method, this method instead returns an\r\ninstance of Git::Wrapper::Statuses:\r\n\r\n    my $statuses = $git->status;\r\n\r\nGit::Wrapper:Statuses has two public methods. First, `is_dirty`:\r\n\r\n    my $dirty_flag = $statuses->is_dirty;\r\n\r\nwhich returns a true/false value depending on whether the repository has any\r\nuncommitted changes.\r\n\r\nSecond, `get`:\r\n\r\n    my @status = $statuses->get($group)\r\n\r\nwhich returns an array of Git::Wrapper::Status objects, one per file changed.\r\n\r\nThere are four status groups, each of which may contain zero or more changes.\r\n\r\n- indexed : Changed & added to the index (aka, will be committed)\r\n- changed : Changed but not in the index (aka, won't be committed)\r\n- unknown : Untracked files\r\n- conflict : Merge conflicts\r\n\r\nNote that a single file can occur in more than one group. Eg, a modified file\r\nthat has been added to the index will appear in the 'indexed' list. If it is\r\nsubsequently further modified it will additionally appear in the 'changed'\r\ngroup.\r\n\r\nA Git::Wrapper::Status object has three methods you can call:\r\n\r\n    my $from = $status->from;\r\n\r\nThe file path of the changed file, relative to the repo root. For renames,\r\nthis is the original path.\r\n\r\n    my $to = $status->to;\r\n\r\nRenames returns the new path/name for the path. In all other cases returns\r\nan empty string.\r\n\r\n    my $mode = $status->mode;\r\n\r\nIndicates what has changed about the file.\r\n\r\nWithin each group (except 'conflict') a file can be in one of a number of\r\nmodes, although some modes only occur in some groups (eg, 'added' never appears\r\nin the 'unknown' group).\r\n\r\n- modified\r\n- added\r\n- deleted\r\n- renamed\r\n- copied\r\n- conflict\r\n\r\nAll files in the 'unknown' group will have a mode of 'unknown' (which is\r\nredundant but at least consistent).\r\n\r\nThe 'conflict' group instead has the following modes.\r\n\r\n- 'both deleted' : deleted on both branches\r\n- 'both added'   : added on both branches\r\n- 'both modified' : modified on both branches\r\n- 'added by us'  : added only on our branch\r\n- 'deleted by us' : deleted only on our branch\r\n- 'added by them' : added on the branch we are merging in\r\n- 'deleted by them' : deleted on the branch we are merging in\r\n\r\nSee git-status man page for more details.\r\n\r\n### Example\r\n\r\n    my $git = Git::Wrapper->new('/path/to/git/repo');\r\n    my $statuses = $git->status;\r\n    for my $type (qw<indexed changed unknown conflict>) {\r\n        my @states = $statuses->get($type)\r\n            or next;\r\n        print \"Files in state $type\\n\";\r\n        for (@states) {\r\n            print '  ', $_->mode, ' ', $_->from;\r\n            print ' renamed to ', $_->to\r\n                if $_->mode eq 'renamed';\r\n            print \"\\n\";\r\n        }\r\n    }\r\n\r\n## RUN\r\n\r\nThis method bypasses the output rearranging performed by some of the wrapped\r\nmethods described above (i.e., `log`, `status`, etc.). This can be useful\r\nin various situations, such as when you want to produce a particular log\r\noutput format that isn't compatible with the way `Git::Wrapper` constructs\r\n`Git::Wrapper::Log`, or when you want raw `git status` output that isn't\r\nparsed into a <Git::Wrapper::Status> object.\r\n\r\nThis method should be called with an initial string argument of the `git`\r\nsubcommand you want to run, followed by a hashref containing options and their\r\nvalues, and then a list of any other arguments.\r\n\r\n### Example\r\n\r\n    my $git = Git::Wrapper->new( '/path/to/git/repo' );\r\n\r\n    # the 'log' method returns Git::Wrapper::Log objects\r\n    my @log_objects = $git->log();\r\n\r\n    # while 'RUN('log')' returns an array of chomped lines\r\n    my @log_lines = $git->RUN('log');\r\n\r\n## ERR\r\n\r\nAfter a command has been run, this method will return anything that was sent\r\nto `STDERR`, in the form of an array of chomped lines. This information will\r\nbe cleared as soon as a new command is executed. This method should __\\*NOT\\*__\r\nbe used as a success/failure check, as `git` will sometimes produce output on\r\nSTDERR when a command is successful.\r\n\r\n## OUT\r\n\r\nAfter a command has been run, this method will return anything that was sent\r\nto `STDOUT`, in the form of an array of chomped lines. It is identical to\r\nwhat is returned from the method call that runs the command, and is provided\r\nsimply for symmetry with the `ERR` method. This method should __\\*NOT\\*__ be\r\nused as a success/failure check, as `git` will frequently not have any output\r\nwith a successful command.\r\n\r\n# COMPATIBILITY\r\n\r\nOn Win32 Git::Wrapper is incompatible with msysGit installations earlier than\r\nGit-1.7.1-preview20100612 due to a bug involving the return value of a git\r\ncommand in cmd/git.cmd. If you use the msysGit version distributed with\r\nGitExtensions or an earlier version of msysGit, tests will fail during\r\ninstallation of this module. You can get the latest version of msysGit on the\r\nGoogle Code project page: [http://code.google.com/p/msysgit/downloads](http://code.google.com/p/msysgit/downloads)\r\n\r\n# ENVIRONMENT VARIABLES\r\n\r\nGit::Wrapper normally uses the first 'git' binary in your path. The original\r\noverride provided to change this was by setting the GIT\\_WRAPPER\\_GIT environment\r\nvariable. Now that object creation accepts an override, you are encouraged to\r\ninstead pass the binary location (git\\_binary) to new on object creation.\r\n\r\n# SEE ALSO\r\n\r\n[VCI::VCS::Git](https://metacpan.org/pod/VCI::VCS::Git) is the git implementation for [VCI](https://metacpan.org/pod/VCI), a generic interface to\r\nversion-control systems.\r\n\r\n[Other Perl Git Wrappers](https://metacpan.org/module/Git::Repository#OTHER-PERL-GIT-WRAPPERS)\r\nis a list of other Git interfaces in Perl. If [Git::Wrapper](https://metacpan.org/pod/Git::Wrapper) doesn't scratch\r\nyour itch, possibly one of the modules listed there will.\r\n\r\nGit itself is at [http://git.or.cz](http://git.or.cz).\r\n\r\n# REPORTING BUGS & OTHER WAYS TO CONTRIBUTE\r\n\r\nThe code for this module is maintained on GitHub, at\r\n[https://github.com/genehack/Git-Wrapper](https://github.com/genehack/Git-Wrapper). If you have a patch, feel free to\r\nfork the repository and submit a pull request. If you find a bug, please open\r\nan issue on the project at GitHub. (We also watch the [http://rt.cpan.org](http://rt.cpan.org)\r\nqueue for Git::Wrapper, so feel free to use that bug reporting system if you\r\nprefer)\r\n\r\n# AUTHORS\r\n\r\n- Hans Dieter Pearcey <hdp@cpan.org>\r\n- Chris Prather <chris@prather.org>\r\n- John SJ Anderson <genehack@genehack.org>\r\n\r\n# COPYRIGHT AND LICENSE\r\n\r\nThis software is copyright (c) 2014 by Hans Dieter Pearcey.\r\n\r\nThis is free software; you can redistribute it and/or modify it under\r\nthe same terms as the Perl 5 programming language system itself.\r\n","google":"UA-31269791-1","note":"Don't delete this file! It's used internally to help with page regeneration."}